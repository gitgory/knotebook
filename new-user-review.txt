================================================================================
KNOTEBOOK - NEW USER REVIEW
================================================================================
Analysis Date: 2026-02-01
Reviewer: Fresh eyes perspective on codebase
Files Analyzed: app.js (4846 lines), index.html, main.css, design-spec.txt

This document catalogs counterintuitive patterns, potential pitfalls, missing
basic features, unhandled edge cases, and potential UI/UX traps discovered
through deep code analysis.

================================================================================
SEVERITY CLASSIFICATION
================================================================================
CRITICAL:  Data loss or corruption, app-breaking bugs
HIGH:      Major UX issues, confusing behavior, missing essential features
MEDIUM:    Inconsistencies, minor confusion, quality-of-life issues
LOW:       Polish items, accessibility improvements, nice-to-haves

================================================================================
CRITICAL SEVERITY ISSUES
================================================================================

1. NESTED NOTE LOSS ON DELETE
   Location: app.js lines 1740-1761 (deleteNode function)

   Problem: When deleting a node that has children, only the immediate children
   are promoted to the current level. If those children have their own children
   (grandchildren of the deleted node), those deeper notes are lost forever.

   The code only handles one level:
   ```
   if (node.children && node.children.length > 0) {
       node.children.forEach((child, index) => {
           state.nodes.push(child);  // Only immediate children
       });
   }
   ```

   Impact: Permanent, unrecoverable data loss. User has no warning that their
   deeply nested structure will be destroyed.

   User scenario: Create note A → step into it → create note B → step into B →
   create notes C and D → go back to A's level → delete A. Notes B is promoted,
   but notes C and D inside B are completely lost.


2. LOCALSTORAGE QUOTA NOT CHECKED
   Location: app.js lines 206-233 (saveProjectToStorage)

   Problem: Data is saved to localStorage without checking quota limits or
   catching QuotaExceededError. On browsers with limited storage or if user
   has many large projects, saves will silently fail.

   Impact: User makes changes, thinks they're saved (auto-save runs), but data
   is actually lost when they close the tab. No error message shown.

   User scenario: User with 10+ large notebooks creates a new project, adds
   100 notes, auto-save triggers but fails due to quota. User closes browser
   thinking work is saved. On reload, the new project is empty or doesn't exist.


3. AUTO-SAVE RACE CONDITION WITH TAB CLOSE
   Location: app.js lines 360-368 (scheduleAutoSave), 4840-4845 (beforeunload)

   Problem: Auto-save debounces for 1.5 seconds. If user makes changes and
   immediately closes the tab within that window:
   - Changes might not be saved to localStorage
   - beforeunload warning only fires if autoSaveTimeout is pending
   - Browser might close before async save completes

   Impact: Recent changes lost on tab close. More likely on slower devices or
   with large project data.

   User scenario: Edit note title, press Esc to close editor (change made),
   immediately close browser tab. The 1.5s timer hasn't fired yet, change is
   lost permanently.


4. ROOT STATE NOT SAVED BEFORE NAVIGATION IN ALL PATHS
   Location: app.js lines 2053-2081 (enterNode), 2125-2130 (saveRootState)

   Problem: When navigating between nested levels, root state should always be
   preserved in rootNodes/rootEdges. However, saveRootState() is only called
   in specific code paths. Some navigation sequences can leave root state stale.

   Impact: Data corruption or loss when editing root-level nodes, then stepping
   into a child, then navigating back. Root changes might not be preserved.

   User scenario: Edit a root node's content, immediately press Enter to step
   into it without closing the editor first, make changes at child level, go
   back to root. Original root edit might be lost.


5. MOVE TO NOTEBOOK CAN DUPLICATE NODES ON FAILURE
   Location: app.js lines 2887-2931 (placeGhostNodes), 3004 (cleanup)

   Problem: When moving nodes to another notebook:
   1. Nodes are copied to target notebook
   2. removeNodesFromSourceNotebook() is called to clean up source
   If step 2 fails silently, nodes exist in BOTH notebooks.

   Impact: Data duplication, confusion about which copy is "real", potential
   for divergent edits in both notebooks.

   User scenario: Move 10 nodes from Project A to Project B. Source cleanup
   fails due to localStorage error. Both projects now have the same 10 nodes.
   User edits copies in both places, creating conflicting versions.


================================================================================
HIGH SEVERITY ISSUES
================================================================================

6. NO COPY/PASTE FUNCTIONALITY
   Location: Missing from codebase

   Problem: Users expect Ctrl+C/Ctrl+V to copy and paste nodes. Instead:
   - Ctrl+Drag duplicates (not intuitive)
   - No clipboard functionality at all
   - No visual affordance that Ctrl+Drag does anything special

   Impact: Difficult to duplicate notes, unintuitive workflow, users may not
   discover duplication feature at all.


7. FILTER CLEAR CLEARS BOTH FILTERS UNEXPECTEDLY
   Location: app.js lines 641-660 (clearFilter)

   Problem: Function named clearFilter() clears BOTH hashtag filter AND text
   search filter. These should be independent. Clear button on hashtag filter
   wipes out unrelated text search.

   Impact: User loses their text search query when they just wanted to remove
   a hashtag filter. Frustrating when they had a complex search term entered.

   User scenario: Search for "meeting notes", filter by #urgent, decide to
   remove #urgent filter, click X button. Both "meeting notes" search and
   #urgent filter are cleared.


8. SELECTION BOX DRAG DIRECTION IS BACKWARDS
   Location: app.js lines 3548-3559, 3615-3638 (selection box)

   Problem: Selection mode determined by drag direction:
   - Drag RIGHT-to-LEFT = "enclosed" (fully contained)
   - Drag LEFT-to-RIGHT = "intersecting" (touching)

   This is BACKWARDS from standard design patterns (Windows, Figma, etc.)
   where left-to-right is strict/enclosed and right-to-left is loose.

   Impact: Users with muscle memory from other apps will select the wrong nodes
   repeatedly, causing frustration and confusion.


9. TAP-TO-ADD MODE HAS NO VISUAL FEEDBACK (Mobile)
   Location: app.js lines 3898-3910, 4154-4170

   Problem: After long-pressing a node on mobile, "tap-to-add mode" is enabled
   (variable tapToAddMode = true). This lets you tap other nodes to add them to
   selection. However:
   - No visual indicator that this mode is active
   - No way to exit except tapping elsewhere
   - Tapping a node might unexpectedly add it to selection

   Impact: Mobile users confused why tapping nodes behaves differently sometimes.
   No affordance for understanding or controlling this hidden state.


10. HASHTAG CASE SENSITIVITY INCONSISTENCY
    Location: app.js lines 552-556 (parseHashtags), 600-602 (filter matching)

    Problem: Hashtags preserve case when parsed (#TODO vs #todo are different),
    but filtering treats them as the same (case-insensitive matching).

    Impact: Sidebar shows #TODO and #todo as separate entries with separate
    counts, but filtering for one matches both. Cognitive dissonance.

    User scenario: Type #TODO in 3 notes and #todo in 2 notes. Sidebar shows
    both as separate tags. Filter by #todo and all 5 notes appear. User is
    confused why #TODO notes are showing when filtering for lowercase #todo.


11. SILENT FAILURES ON INVALID OPERATIONS
    Location: Multiple locations

    Problems:
    a) Self-edges prevented silently (lines 1990-1996)
       User tries to connect node to itself, nothing happens, no feedback.

    b) Alt+Click on unselected node does nothing (lines 3487-3497)
       User expects it to add to selection or give feedback, just silent.

    c) Go back from root does nothing (lines 2083-2111)
       Pressing Alt+Up at root level has no effect, no indication why.

    d) Fit to View when no nodes exist does nothing visible (lines 1208-1215)
       Just silently resets viewport, no feedback about empty canvas.

    Impact: Users think features are broken when they're actually working as
    designed. No error messages or explanations provided.


12. ENTER KEY BEHAVIOR CHANGES AT 600PX VIEWPORT
    Location: app.js lines 4554-4566

    Problem: Editor behavior for Enter key:
    - Desktop (>600px): Enter saves and closes editor
    - Mobile (≤600px): Enter inserts newline

    But detection is purely viewport width based, not device-based. A tablet in
    landscape might be >600px (desktop behavior) then rotated to portrait <600px
    (mobile behavior). Or a desktop window resized to 600px changes behavior.

    Impact: Inconsistent user experience, muscle memory doesn't work, users on
    tablets get unpredictable behavior based on orientation.


13. BATCH EDIT TAG COUNTS DON'T UPDATE IN REAL-TIME
    Location: app.js lines 2195, 2385-2405

    Problem: In batch edit mode, hashtag pills show "(x/y)" count where x is how
    many selected nodes have this tag. But if you remove a tag by clicking the
    pill, the count doesn't update until you save. The "(2/3)" display makes you
    think you're only removing from 2/3 nodes when actually all 3 will have it
    removed.

    Impact: Confusing feedback during batch edit, users don't understand the
    effect of their changes until after saving.


14. IMPORT OVERWRITE USES PROMPT() FOR NOTEBOOK SELECTION
    Location: app.js lines 3389-3405

    Problem: When importing and choosing to overwrite, user gets a numbered list
    in a prompt() dialog asking them to type a number. This breaks down when:
    - Long notebook names get truncated but list shows full name
    - Many notebooks make the prompt unreadable
    - No confirmation shown before overwriting
    - Easy to mistype number and overwrite wrong notebook

    Impact: High risk of accidentally overwriting the wrong notebook. Ancient UX
    pattern (prompt() dialogs) in an otherwise modern app.


15. NO UNDO/REDO
    Location: Missing from codebase

    Problem: No undo/redo functionality at all. Once you delete a node, move it,
    or make any change, it's permanent (except for editor Cancel button which
    only works while editor is open).

    Impact: Accidental deletes, moves, or edits are permanent. Users expect
    Ctrl+Z in modern apps. This is especially critical given issue #1 where
    deleting nodes can lose nested children.


================================================================================
MEDIUM SEVERITY ISSUES
================================================================================

16. HASHTAG AUTOCOMPLETE STOPS AT SPACES
    Location: app.js lines 2643-2659

    Problem: Autocomplete only scans word characters [\w-] to find hashtags.
    If user types "#my project" and wants to autocomplete "project", the
    autocomplete thinks they're searching for "my" if cursor is after the space.

    Impact: Can't autocomplete multi-word tags effectively, limiting usefulness
    of autocomplete for complex tag names.


17. FIT TO VIEW USES ACTIVE FILTERS SILENTLY
    Location: app.js lines 1202-1240 (fitToView)

    Problem: When filters are active, "Fit to View" zooms to fit only visible
    nodes. But there's no indication that filters affect this behavior.

    Impact: User filters to #important, sees 2 nodes, clicks Fit to View,
    wonders why it only zoomed to those 2 when they have 50 total nodes.
    Behavior is correct but unexpected.


18. TITLE HOVER EXPANSION IS INVISIBLE
    Location: app.js lines 3701-3733

    Problem: Node titles expand on hover after 500ms if truncated. But:
    - No cursor change or visual cue that expansion is available
    - Expanded text might be cut off by viewport
    - Mobile users can't hover, never see full titles

    Impact: Users don't discover this feature. On mobile, long titles are
    permanently truncated with no way to see full text except by editing.


19. EDGE DELETION HAS NO CONTEXT MENU
    Location: app.js lines 2041-2047

    Problem: Edges can be selected and deleted via Delete key, but:
    - Right-clicking an edge does nothing (no context menu)
    - Inconsistent with node workflow (nodes have right-click menu)
    - Users must discover Delete key works, no visual affordance

    Impact: Users may not realize edges can be deleted, or may click repeatedly
    on an edge expecting a menu to appear.


20. BREADCRUMB CLICK ONLY GOES BACK ONE LEVEL
    Location: app.js lines 4629-4634

    Problem: Clicking breadcrumbs calls goBack() which goes back ONE level.
    If navigation path is "Root > A > B > C" and user clicks "Root", they only
    go back to "Root > A > B". Must click multiple times to reach root.

    Impact: Inefficient navigation, unexpected behavior (users expect clicking
    Root to jump directly to root level).


21. HIDDEN HASHTAGS APPEAR IN GRADIENT
    Location: app.js lines 956-1068, CSS for sidebar

    Problem: When you hide a hashtag via sidebar, it shows in the sidebar with
    a gray-to-color gradient to indicate it's hidden. But:
    - Not obvious that gradient means "hidden"
    - No tooltip explaining the visual state
    - Color gradient might look like a design choice rather than status indicator

    Impact: Users don't understand what the gradient means, may think it's just
    a different color scheme.


22. COMPLETION STATUS CYCLE NOT DOCUMENTED IN UI
    Location: app.js lines 578-585 (cycleCompletion)

    Problem: Completion cycles through: null → no → partial → yes → cancelled → no

    But the editor shows buttons for all 5 states, implying you can directly
    select any state. The cycle is only revealed by clicking the node indicator
    repeatedly. Users might not know cancelled comes after done.

    Impact: Users think they can't set cancelled status directly from editor
    buttons when actually they can (there's a "Cancelled" button).


23. HASHTAG RENAME CAN CREATE CASE DUPLICATES
    Location: app.js lines 740-791 (renameHashtag)

    Problem: Renaming #todo to #TODO updates content and re-parses hashtags.
    But if case-insensitive duplicate now exists elsewhere, no merge happens.
    User ends up with both #TODO and #todo in their notebook.

    Impact: Tag proliferation, duplicates that filter treats as same but sidebar
    shows as separate entries.


24. MOBILE SIDEBAR AUTO-CLOSES ON CANVAS TOUCH
    Location: app.js lines 3842-3846

    Problem: When user touches anywhere on canvas, sidebar closes automatically.
    This prevents common workflow: open sidebar, filter by tag, pan/zoom to
    see filtered notes.

    Impact: Mobile users can't effectively use sidebar filtering while viewing
    the canvas. Must remember to apply filter, close sidebar, then view results.


25. NO VISUAL FEEDBACK FOR AUTO-SAVE STATUS
    Location: Missing from codebase

    Problem: App auto-saves every 1.5 seconds but shows no indicator. Users
    don't know if:
    - Changes have been saved
    - Save is pending
    - Save failed (localStorage quota exceeded)

    Impact: Uncertainty about data persistence. Users may close tab prematurely
    or wait unnecessarily thinking save is still in progress.


26. BATCH CONNECT PROVIDES NO FEEDBACK
    Location: app.js lines 1999-2013

    Problem: When connecting multiple selected nodes to a target, the operation:
    - Creates all edges, even duplicates of existing edges
    - Provides no feedback about which edges were new vs already existed
    - No confirmation dialog showing what will be connected

    Impact: Users might create redundant edges without realizing it, or not
    understand which nodes got connected to the target.


27. SETTINGS MODAL CONTEXT INCONSISTENCY
    Location: app.js lines 3073-3090 (showSettings)

    Problem: Settings can be opened from:
    1. Toolbar gear icon (uses current in-memory project settings)
    2. Project context menu (loads from localStorage)

    If user opens settings for Project A while Project B is open, changes won't
    affect current project. State can become inconsistent.

    Impact: Confusing which project's settings are being modified, possible
    unintended changes to wrong project.


28. DEEP COPY LOSES CREATION TIMESTAMPS
    Location: app.js lines 1701-1738 (deepCopyNode)

    Problem: When duplicating or moving nodes, new timestamps are created:
    ```
    created: new Date().toISOString(),
    modified: new Date().toISOString()
    ```

    Original creation date is lost. No way to track when the original note was
    actually created.

    Impact: Can't sort by creation date, can't track note history, duplicate
    notes appear newer than they actually are conceptually.


29. EMPTY NOTES CAN EXIST IN EDGE CASES
    Location: app.js lines 4236-4238, 2374-2376

    Problem: Notes are supposed to be deleted if empty on editor close (line
    2292-2294). But if you:
    - Create note, add whitespace-only title, save
    - Create note, add hashtags then delete them, save with empty content

    Empty notes can persist. They're invisible (no title text) but take up space
    and create confusion.

    Impact: Invisible nodes on canvas that users can't identify or clean up
    without opening the editor to see they're empty.


30. VIEWPORT ZOOM LIMITS DIFFER BY PLATFORM
    Location: app.js lines 1188 (desktop), 3971 (mobile)

    Problem:
    - Desktop zoom: 0.5x to 2.5x
    - Mobile pinch: 0.5x to 5x

    Mobile users can zoom twice as far as desktop, creating inconsistent
    experience across devices.

    Impact: Users switching between desktop and mobile notice different zoom
    capabilities, might think desktop is broken when they can't zoom past 2.5x.


================================================================================
LOW SEVERITY ISSUES
================================================================================

31. NO KEYBOARD FOCUS INDICATORS
    Location: CSS, accessibility

    Problem: Many keyboard shortcuts exist, but no visible focus ring on
    interactive elements. Users navigating via Tab key can't tell which element
    is focused.

    Impact: Poor keyboard navigation experience, accessibility issue for users
    who rely on keyboard instead of mouse.


32. NO ARIA LABELS ON SVG ELEMENTS
    Location: SVG rendering code

    Problem: Graph is rendered as SVG without ARIA labels. Screen readers can't
    interpret the structure or read node contents.

    Impact: App is unusable for users relying on screen readers. Major
    accessibility gap.


33. SYMBOLIC TOOLBAR BUTTONS LACK TOOLTIPS
    Location: index.html lines 66-71

    Problem: Buttons use symbols (⌂, ⬇, ⛶, etc.) with title attributes for
    hover tooltips, but:
    - Symbols might not render on all systems/fonts
    - No fallback text for when symbols don't display
    - Mobile users don't see tooltips (no hover)

    Impact: Buttons become cryptic if symbols don't render. Mobile users must
    guess what buttons do.


34. HASHTAG SIDEBAR AND TEXT SEARCH REDUNDANCY
    Location: index.html line 125 comment, design decision

    Problem: The app has both:
    - Hashtag sidebar with filter input
    - Text search bar in toolbar

    They overlap in functionality but work differently:
    - Text search = substring match on title/content
    - Hashtag filter = exact tag match

    Developer even left TODO comment: "Consider removing entirely (use text
    search) or merging with text search bar"

    Impact: Cognitive overhead of two similar but different search mechanisms.
    Users might not understand when to use which.


35. COLOR-ONLY STATUS INDICATORS
    Location: Completion status, hashtag colors

    Problem: Some status information conveyed only by color:
    - Hashtag colors (different tags = different colors)
    - Task status uses symbols (✓, ◐, ✕) which is good, but background colors
      for "Done" vs "Partial" might be indistinguishable for colorblind users

    Impact: Users with color vision deficiency might not distinguish status or
    tags as easily.


36. NO MAX NESTING DEPTH LIMIT
    Location: app.js lines 2053-2081 (enterNode)

    Problem: Unlimited nesting depth means:
    - Breadcrumbs get truncated when too long
    - Performance could degrade with very deep nesting
    - No warning when nesting becomes impractically deep

    Impact: Users can create deeply nested structures that are hard to navigate
    back from or understand. Performance degradation possible.


37. HASHTAG PARSING DOESN'T SUPPORT ACCENTS
    Location: app.js lines 552-556, regex /#[\w-]+/g

    Problem: Regex only matches word characters and hyphens. This means:
    - #café won't parse (é is not \w in JavaScript)
    - #résumé won't parse
    - Non-English hashtags often fail

    Impact: International users can't use hashtags with their native language
    characters. Tags silently don't work.


38. FULL RE-RENDER ON EVERY STATE CHANGE
    Location: app.js lines 1253-1270 (render function)

    Problem: Every change triggers complete re-render of all nodes, edges,
    selection box, breadcrumbs, and sidebar. No dirty checking or partial
    updates.

    Impact: Performance degrades with large graphs (1000+ nodes). Unnecessary
    re-renders waste CPU cycles.


39. DEEP COPY RECURSION COULD STACK OVERFLOW
    Location: app.js lines 1701-1738 (deepCopyNode)

    Problem: Recursive deepCopyNode() has no depth limit. If user has 100+
    levels of nesting and duplicates a deeply nested node, could hit stack limit.

    Impact: App crash on duplicate operation with extreme nesting depth. Rare
    but possible.


40. NO PROJECT SIZE WARNING
    Location: localStorage operations

    Problem: No indication of project size or remaining localStorage quota.
    Users don't know when they're approaching limits.

    Impact: Sudden save failures when quota is reached, no advance warning to
    export or clean up data.


41. EDGES TO DELETED CHILD NODES NOT CLEANED
    Location: app.js lines 1763-1764 (deleteNode)

    Problem: When node with childEdges is deleted, edges connected to the node
    at current level are cleaned up. But childEdges referencing deleted child
    nodes might not be cleaned recursively.

    Impact: Orphaned edge references in data structure, potential rendering
    errors or data corruption.


42. ID COLLISION RISK WITH RAPID NODE CREATION
    Location: app.js lines 549 (generateId)

    Problem: IDs generated as `note-${Date.now()}-${state.nextId++}`. While
    nextId counter prevents collisions in same session, Date.now() can have
    collisions if:
    - System clock is adjusted
    - Multiple nodes created in rapid succession when Date.now() hasn't changed
    - Move operations across notebooks with same timestamp

    Impact: Low probability but possible ID collision leading to data corruption.


43. SELECTION BOX CAN BE CREATED OVER MODALS
    Location: app.js lines 3548-3559

    Problem: If modal is open and canvas is partially visible, user might
    accidentally trigger selection box on the canvas behind the modal.

    Impact: Unexpected selection changes while trying to interact with modal.
    Visual confusion.


44. NO BATCH OPERATION PREVIEW
    Location: Batch delete, batch edit operations

    Problem: When doing batch operations on multiple selected nodes, no preview
    or confirmation showing exactly which nodes will be affected.

    Impact: Users might accidentally modify/delete unintended nodes, especially
    if selection was done via selection box and they didn't notice all selected
    nodes.


45. THEME CHANGES DON'T PRESERVE CONTRAST
    Location: Theme system, CSS color variables

    Problem: When switching themes, hashtag colors stay the same. A color that
    has good contrast in Midnight theme might have poor contrast in Sky theme.

    Impact: Some hashtag pills might become hard to read when switching themes.


================================================================================
MISSING BASIC FEATURES
================================================================================

46. No Ctrl+A to Select All
    Expected: Select all visible nodes
    Current: Not implemented

47. No Shift+Click Range Selection
    Expected: Select range of nodes between two clicks
    Current: Not implemented

48. No Export to Other Formats
    Expected: Export as Markdown, plain text, or other common formats
    Current: Only JSON export

49. No Search Across All Nested Levels
    Expected: Search entire notebook including nested children
    Current: Search only searches current level

50. No Link/URL Support in Notes
    Expected: Clickable URLs in note content
    Current: Plain text only

51. No Rich Text Formatting
    Expected: At minimum bold, italic, lists
    Current: Plain text only (by design, but users might expect it)

52. No Note-to-Note Links (WikiLinks)
    Expected: Ability to link from one note to another
    Current: Only edges show relationships, no in-note references

53. No Drag Node to Make Child
    Expected: Drag node onto another to nest it as child
    Current: Must use editor "Step in" button, not intuitive

54. No Multi-Notebook View
    Expected: See multiple notebooks side-by-side
    Current: One notebook at a time

55. No Export Selection Only
    Expected: Export only selected nodes to new file
    Current: Export exports entire notebook


================================================================================
COUNTERINTUITIVE PATTERNS
================================================================================

56. CTRL+DRAG TO DUPLICATE
    Pattern: Ctrl+Drag duplicates nodes
    Why counterintuitive: Most apps use Ctrl+C/Ctrl+V. Drag-based duplication
    is not discoverable. No visual feedback during Ctrl+Drag that duplication
    will occur.


57. SHIFT+CLICK TO TOGGLE EDGES
    Pattern: Shift+Click node starts edge creation, Shift+Click again completes
    Why counterintuitive: Shift is usually for multi-select. Using it for edges
    conflicts with user expectations. Plus Shift+Drag also creates edges, so
    two different Shift-based operations.


58. DOUBLE-CLICK TO EDIT
    Pattern: Double-click opens editor
    Why counterintuitive: In graph apps, double-click often zooms or steps into
    nodes. The app uses click on stacked area to step in, which users might
    not discover.


59. HASHTAG FILTER AS SEARCH
    Pattern: Hashtag filter input in sidebar works like search
    Why counterintuitive: Two separate search inputs (text search in toolbar,
    hashtag filter in sidebar) that work differently but look similar. Users
    might not realize they're separate systems.


60. ESC KEY SAVES EDITOR
    Pattern: Pressing Escape in editor saves and closes
    Why counterintuitive: In most apps, Escape = cancel. Here it saves. The
    Cancel button is the red X in the corner.


61. FILTERS AFFECT FIT TO VIEW
    Pattern: Active filters change which nodes are included in Fit to View
    Why counterintuitive: Users think of Fit to View as "show me everything" but
    it respects filters, so it might show a small subset.


62. CLICKING HASHTAG IN EDITOR FILTERS
    Pattern: Click a hashtag pill in the editor to filter by that tag
    Why counterintuitive: Pills look like status indicators, not clickable
    filters. No hover state or cursor change to indicate clickability.


63. RIGHT-DRAG TO PAN
    Pattern: Right-click and drag to pan canvas while preserving selection
    Why counterintuitive: Most apps use middle-click drag or spacebar+drag.
    Right-drag often brings up context menus.


64. STEP INTO BUTTON CHANGES COLOR
    Pattern: "Step in" button in editor is gray when empty, green when has children
    Why counterintuitive: Color change doesn't clearly communicate why. Users
    might think gray = disabled, try to click it, and be confused when it works
    (creates empty nested level).


65. NODE DELETION PROMOTES CHILDREN
    Pattern: Deleting node moves its children up to current level
    Why counterintuitive: Most apps delete recursively (delete node and all
    descendants). This promotes children, which might be helpful but unexpected.


================================================================================
RECOMMENDATIONS SUMMARY
================================================================================

TOP PRIORITY FIXES:
1. Fix nested note loss on delete (issue #1)
2. Add localStorage quota checking and error handling (issue #2)
3. Implement reliable save before tab close (issue #3)
4. Add copy/paste functionality (issue #6)
5. Add undo/redo (issue #15)

HIGH PRIORITY UX IMPROVEMENTS:
6. Separate text search and hashtag filter clear buttons (issue #7)
7. Add visual feedback for tap-to-add mode on mobile (issue #9)
8. Improve import overwrite UX with proper modal (issue #14)
9. Add confirmation dialogs for destructive operations
10. Add auto-save status indicator (issue #25)

MEDIUM PRIORITY ENHANCEMENTS:
11. Implement breadcrumb jump navigation (issue #20)
12. Add edge context menu (issue #19)
13. Fix selection box drag direction (issue #8)
14. Add tooltips and help text for hidden features
15. Improve accessibility with ARIA labels and focus indicators

ARCHITECTURAL CONSIDERATIONS:
16. Consider partial/dirty rendering for performance (issue #38)
17. Add nesting depth limit (issue #36)
18. Unify search/filter UX (issue #34)
19. Add data validation and error boundaries
20. Implement proper error handling throughout

================================================================================
END OF REVIEW
================================================================================
